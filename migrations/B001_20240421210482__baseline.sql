-- Script generated by Redgate Compare v1.19.7.21721


-- deployment: Creating inventory_in_stock...
CREATE FUNCTION inventory_in_stock (p_inventory_id int)
RETURNS tinyint(1)
READS SQL DATA
BEGIN
    DECLARE v_rentals INT;
    DECLARE v_out     INT;

    #AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
    #FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED

    SELECT COUNT(*) INTO v_rentals
    FROM rental
    WHERE inventory_id = p_inventory_id;

    IF v_rentals = 0 THEN
      RETURN TRUE;
    END IF;

    SELECT COUNT(rental_id) INTO v_out
    FROM inventory LEFT JOIN rental USING(inventory_id)
    WHERE inventory.inventory_id = p_inventory_id
    AND rental.return_date IS NULL;

    IF v_out > 0 THEN
      RETURN FALSE;
    ELSE
      RETURN TRUE;
    END IF;
END;


-- deployment: Creating inventory_held_by_customer...
CREATE FUNCTION inventory_held_by_customer (p_inventory_id int)
RETURNS int
READS SQL DATA
BEGIN
  DECLARE v_customer_id INT;
  DECLARE EXIT HANDLER FOR NOT FOUND RETURN NULL;

  SELECT customer_id INTO v_customer_id
  FROM rental
  WHERE return_date IS NULL
  AND inventory_id = p_inventory_id;

  RETURN v_customer_id;
END;


-- deployment: Creating get_customer_balance...
CREATE FUNCTION get_customer_balance (p_customer_id int, p_effective_date datetime)
RETURNS decimal(5,2)
DETERMINISTIC
READS SQL DATA
BEGIN

       #OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
       #THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
       #   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
       #   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
       #   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
       #   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED

  DECLARE v_rentfees DECIMAL(5,2); #FEES PAID TO RENT THE VIDEOS INITIALLY
  DECLARE v_overfees INTEGER;      #LATE FEES FOR PRIOR RENTALS
  DECLARE v_payments DECIMAL(5,2); #SUM OF PAYMENTS MADE PREVIOUSLY

  SELECT IFNULL(SUM(film.rental_rate),0) INTO v_rentfees
    FROM film, inventory, rental
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;

  SELECT IFNULL(SUM(IF((TO_DAYS(rental.return_date) - TO_DAYS(rental.rental_date)) > film.rental_duration,
        ((TO_DAYS(rental.return_date) - TO_DAYS(rental.rental_date)) - film.rental_duration),0)),0) INTO v_overfees
    FROM rental, inventory, film
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;


  SELECT IFNULL(SUM(payment.amount),0) INTO v_payments
    FROM payment

    WHERE payment.payment_date <= p_effective_date
    AND payment.customer_id = p_customer_id;

  RETURN v_rentfees + v_overfees - v_payments;
END;


-- deployment: Creating rewards_report...
CREATE PROCEDURE rewards_report (IN min_monthly_purchases tinyint unsigned, IN min_dollar_amount_purchased decimal(10,2), OUT count_rewardees int)
COMMENT 'Provides a customizable report on best customers'
READS SQL DATA
proc: BEGIN

    DECLARE last_month_start DATE;
    DECLARE last_month_end DATE;

    /* Some sanity checks... */
    IF min_monthly_purchases = 0 THEN
        SELECT 'Minimum monthly purchases parameter must be > 0';
        LEAVE proc;
    END IF;
    IF min_dollar_amount_purchased = 0.00 THEN
        SELECT 'Minimum monthly dollar amount purchased parameter must be > $0.00';
        LEAVE proc;
    END IF;

    /* Determine start and end time periods */
    SET last_month_start = DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH);
    SET last_month_start = STR_TO_DATE(CONCAT(YEAR(last_month_start),'-',MONTH(last_month_start),'-01'),'%Y-%m-%d');
    SET last_month_end = LAST_DAY(last_month_start);

    /*
        Create a temporary storage area for
        Customer IDs.
    */
    CREATE TEMPORARY TABLE tmpCustomer (customer_id SMALLINT UNSIGNED NOT NULL PRIMARY KEY);

    /*
        Find all customers meeting the
        monthly purchase requirements
    */
    INSERT INTO tmpCustomer (customer_id)
    SELECT p.customer_id
    FROM payment AS p
    WHERE DATE(p.payment_date) BETWEEN last_month_start AND last_month_end
    GROUP BY customer_id
    HAVING SUM(p.amount) > min_dollar_amount_purchased
    AND COUNT(customer_id) > min_monthly_purchases;

    /* Populate OUT parameter with count of found customers */
    SELECT COUNT(*) FROM tmpCustomer INTO count_rewardees;

    /*
        Output ALL customer information of matching rewardees.
        Customize output as needed.
    */
    SELECT c.*
    FROM tmpCustomer AS t
    INNER JOIN customer AS c ON t.customer_id = c.customer_id;

    /* Clean up */
    DROP TABLE tmpCustomer;
END;


-- deployment: Creating film_not_in_stock...
CREATE PROCEDURE film_not_in_stock (IN p_film_id int, IN p_store_id int, OUT p_film_count int)
READS SQL DATA
BEGIN
     SELECT inventory_id
     FROM inventory
     WHERE film_id = p_film_id
     AND store_id = p_store_id
     AND NOT inventory_in_stock(inventory_id);

     SELECT COUNT(*)
     FROM inventory
     WHERE film_id = p_film_id
     AND store_id = p_store_id
     AND NOT inventory_in_stock(inventory_id)
     INTO p_film_count;
END;


-- deployment: Creating film_in_stock...
CREATE PROCEDURE film_in_stock (IN p_film_id int, IN p_store_id int, OUT p_film_count int)
READS SQL DATA
BEGIN
     SELECT inventory_id
     FROM inventory
     WHERE film_id = p_film_id
     AND store_id = p_store_id
     AND inventory_in_stock(inventory_id);

     SELECT COUNT(*)
     FROM inventory
     WHERE film_id = p_film_id
     AND store_id = p_store_id
     AND inventory_in_stock(inventory_id)
     INTO p_film_count;
END;


-- deployment: Creating store...
CREATE TABLE store (
    store_id tinyint unsigned NOT NULL,
    manager_staff_id tinyint unsigned NOT NULL,
    address_id smallint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE store ADD PRIMARY KEY (store_id);


-- deployment: Creating staff...
CREATE TABLE staff (
    staff_id tinyint unsigned NOT NULL,
    first_name varchar(45) NOT NULL,
    last_name varchar(45) NOT NULL,
    address_id smallint unsigned NOT NULL,
    picture blob NULL,
    email varchar(50) NULL,
    store_id tinyint unsigned NOT NULL,
    active tinyint(1) NOT NULL DEFAULT 1,
    username varchar(16) NOT NULL,
    password varchar(40) NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE staff ADD PRIMARY KEY (staff_id);


-- deployment: Creating rental...
CREATE TABLE rental (
    rental_id int NOT NULL,
    rental_date datetime NOT NULL,
    inventory_id mediumint unsigned NOT NULL,
    customer_id smallint unsigned NOT NULL,
    return_date datetime NULL,
    staff_id tinyint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE rental ADD PRIMARY KEY (rental_id);


-- deployment: Creating rental_date...
CREATE TRIGGER rental_date
BEFORE INSERT ON rental
FOR EACH ROW
SET NEW.rental_date = NOW();


-- deployment: Creating payment...
CREATE TABLE payment (
    payment_id smallint unsigned NOT NULL,
    customer_id smallint unsigned NOT NULL,
    staff_id tinyint unsigned NOT NULL,
    rental_id int NULL,
    amount decimal(5,2) NOT NULL,
    payment_date datetime NOT NULL,
    last_update timestamp NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE payment ADD PRIMARY KEY (payment_id);


-- deployment: Creating payment_date...
CREATE TRIGGER payment_date
BEFORE INSERT ON payment
FOR EACH ROW
SET NEW.payment_date = NOW();


-- deployment: Creating language...
CREATE TABLE language (
    language_id tinyint unsigned NOT NULL,
    name char(20) NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE language ADD PRIMARY KEY (language_id);


-- deployment: Creating inventory...
CREATE TABLE inventory (
    inventory_id mediumint unsigned NOT NULL,
    film_id smallint unsigned NOT NULL,
    store_id tinyint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE inventory ADD PRIMARY KEY (inventory_id);


-- deployment: Creating film_text...
CREATE TABLE film_text (
    film_id smallint NOT NULL,
    title varchar(255) NOT NULL,
    description text NULL
);
ALTER TABLE film_text ADD PRIMARY KEY (film_id);


-- deployment: Creating film_category...
CREATE TABLE film_category (
    film_id smallint unsigned NOT NULL,
    category_id tinyint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE film_category ADD PRIMARY KEY (film_id, category_id);


-- deployment: Creating film_actor...
CREATE TABLE film_actor (
    actor_id smallint unsigned NOT NULL,
    film_id smallint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE film_actor ADD PRIMARY KEY (actor_id, film_id);


-- deployment: Creating film...
CREATE TABLE film (
    film_id smallint unsigned NOT NULL,
    title varchar(128) NOT NULL,
    description text NULL,
    release_year year NULL,
    language_id tinyint unsigned NOT NULL,
    original_language_id tinyint unsigned NULL,
    rental_duration tinyint unsigned NOT NULL DEFAULT 3,
    rental_rate decimal(4,2) NOT NULL DEFAULT 4.99,
    length smallint unsigned NULL,
    replacement_cost decimal(5,2) NOT NULL DEFAULT 19.99,
    rating enum('G','PG','PG-13','R','NC-17') NULL DEFAULT 'G',
    special_features set('Trailers','Commentaries','Deleted Scenes','Behind the Scenes') NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE film ADD PRIMARY KEY (film_id);


-- deployment: Creating upd_film...
CREATE TRIGGER upd_film
AFTER UPDATE ON film
FOR EACH ROW
BEGIN
    IF (old.title != new.title) OR (old.description != new.description) OR (old.film_id != new.film_id)
    THEN
        UPDATE film_text
            SET title=new.title,
                description=new.description,
                film_id=new.film_id
        WHERE film_id=old.film_id;
    END IF;
  END;


-- deployment: Creating ins_film...
CREATE TRIGGER ins_film
AFTER INSERT ON film
FOR EACH ROW
BEGIN
    INSERT INTO film_text (film_id, title, description)
        VALUES (new.film_id, new.title, new.description);
  END;


-- deployment: Creating del_film...
CREATE TRIGGER del_film
AFTER DELETE ON film
FOR EACH ROW
BEGIN
    DELETE FROM film_text WHERE film_id = old.film_id;
  END;


-- deployment: Creating film_category.fk_film_category_film...
ALTER TABLE film_category
    ADD CONSTRAINT fk_film_category_film FOREIGN KEY (film_id)
    REFERENCES film(film_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating empleados...
CREATE TABLE empleados (
    cod_empleado int NULL,
    nombre varchar(50) NULL,
    apellido1 varchar(50) NULL,
    apellido2 varchar(50) NULL,
    email varchar(50) NULL,
    salario int NULL,
    departamento varchar(11) NULL,
    comision int NULL
);


-- deployment: Creating customer...
CREATE TABLE customer (
    customer_id smallint unsigned NOT NULL,
    store_id tinyint unsigned NOT NULL,
    first_name varchar(45) NOT NULL,
    last_name varchar(45) NOT NULL,
    email varchar(50) NULL,
    address_id smallint unsigned NOT NULL,
    active tinyint(1) NOT NULL DEFAULT 1,
    create_date datetime NOT NULL,
    last_update timestamp NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE customer ADD PRIMARY KEY (customer_id);


-- deployment: Creating customer_create_date...
CREATE TRIGGER customer_create_date
BEFORE INSERT ON customer
FOR EACH ROW
SET NEW.create_date = NOW();


-- deployment: Creating cuentas...
CREATE TABLE cuentas (
    codigo char(27) NULL
);


-- deployment: Creating country...
CREATE TABLE country (
    country_id smallint unsigned NOT NULL,
    country varchar(50) NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE country ADD PRIMARY KEY (country_id);


-- deployment: Creating city...
CREATE TABLE city (
    city_id smallint unsigned NOT NULL,
    city varchar(50) NOT NULL,
    country_id smallint unsigned NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE city ADD PRIMARY KEY (city_id);


-- deployment: Creating category...
CREATE TABLE category (
    category_id tinyint unsigned NOT NULL,
    name varchar(25) NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE category ADD PRIMARY KEY (category_id);


-- deployment: Creating sales_by_film_category...
CREATE VIEW sales_by_film_category AS select `c`.`name` AS `category`,sum(`p`.`amount`) AS `total_sales` from (((((`sakila`.`payment` `p` join `sakila`.`rental` `r` on((`p`.`rental_id` = `r`.`rental_id`))) join `sakila`.`inventory` `i` on((`r`.`inventory_id` = `i`.`inventory_id`))) join `sakila`.`film` `f` on((`i`.`film_id` = `f`.`film_id`))) join `sakila`.`film_category` `fc` on((`f`.`film_id` = `fc`.`film_id`))) join `sakila`.`category` `c` on((`fc`.`category_id` = `c`.`category_id`))) group by `c`.`name` order by `total_sales` desc;


-- deployment: Creating address...
CREATE TABLE address (
    address_id smallint unsigned NOT NULL,
    address varchar(50) NOT NULL,
    address2 varchar(50) NULL,
    district varchar(20) NOT NULL,
    city_id smallint unsigned NOT NULL,
    postal_code varchar(10) NULL,
    phone varchar(20) NOT NULL,
    location geometry NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE address ADD PRIMARY KEY (address_id);


-- deployment: Creating staff_list...
CREATE VIEW staff_list AS select `s`.`staff_id` AS `ID`,concat(`s`.`first_name`,' ',`s`.`last_name`) AS `name`,`a`.`address` AS `address`,`a`.`postal_code` AS `zip code`,`a`.`phone` AS `phone`,`sakila`.`city`.`city` AS `city`,`sakila`.`country`.`country` AS `country`,`s`.`store_id` AS `SID` from (((`sakila`.`staff` `s` join `sakila`.`address` `a` on((`s`.`address_id` = `a`.`address_id`))) join `sakila`.`city` on((`a`.`city_id` = `sakila`.`city`.`city_id`))) join `sakila`.`country` on((`sakila`.`city`.`country_id` = `sakila`.`country`.`country_id`)));


-- deployment: Creating sales_by_store...
CREATE VIEW sales_by_store AS select concat(`c`.`city`,',',`cy`.`country`) AS `store`,concat(`m`.`first_name`,' ',`m`.`last_name`) AS `manager`,sum(`p`.`amount`) AS `total_sales` from (((((((`sakila`.`payment` `p` join `sakila`.`rental` `r` on((`p`.`rental_id` = `r`.`rental_id`))) join `sakila`.`inventory` `i` on((`r`.`inventory_id` = `i`.`inventory_id`))) join `sakila`.`store` `s` on((`i`.`store_id` = `s`.`store_id`))) join `sakila`.`address` `a` on((`s`.`address_id` = `a`.`address_id`))) join `sakila`.`city` `c` on((`a`.`city_id` = `c`.`city_id`))) join `sakila`.`country` `cy` on((`c`.`country_id` = `cy`.`country_id`))) join `sakila`.`staff` `m` on((`s`.`manager_staff_id` = `m`.`staff_id`))) group by `s`.`store_id` order by `cy`.`country`,`c`.`city`;


-- deployment: Creating customer_list...
CREATE VIEW customer_list AS select `cu`.`customer_id` AS `ID`,concat(`cu`.`first_name`,' ',`cu`.`last_name`) AS `name`,`a`.`address` AS `address`,`a`.`postal_code` AS `zip code`,`a`.`phone` AS `phone`,`sakila`.`city`.`city` AS `city`,`sakila`.`country`.`country` AS `country`,if(`cu`.`active`,'active','') AS `notes`,`cu`.`store_id` AS `SID` from (((`sakila`.`customer` `cu` join `sakila`.`address` `a` on((`cu`.`address_id` = `a`.`address_id`))) join `sakila`.`city` on((`a`.`city_id` = `sakila`.`city`.`city_id`))) join `sakila`.`country` on((`sakila`.`city`.`country_id` = `sakila`.`country`.`country_id`)));


-- deployment: Creating actor...
CREATE TABLE actor (
    actor_id smallint unsigned NOT NULL,
    first_name varchar(45) NOT NULL,
    last_name varchar(45) NOT NULL,
    last_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE actor ADD PRIMARY KEY (actor_id);


-- deployment: Creating nicer_but_slower_film_list...
CREATE VIEW nicer_but_slower_film_list AS select `sakila`.`film`.`film_id` AS `FID`,`sakila`.`film`.`title` AS `title`,`sakila`.`film`.`description` AS `description`,`sakila`.`category`.`name` AS `category`,`sakila`.`film`.`rental_rate` AS `price`,`sakila`.`film`.`length` AS `length`,`sakila`.`film`.`rating` AS `rating`,group_concat(concat(concat(upper(substr(`sakila`.`actor`.`first_name`,1,1)),lower(substr(`sakila`.`actor`.`first_name`,2,length(`sakila`.`actor`.`first_name`))),' ',concat(upper(substr(`sakila`.`actor`.`last_name`,1,1)),lower(substr(`sakila`.`actor`.`last_name`,2,length(`sakila`.`actor`.`last_name`)))))) separator ', ') AS `actors` from ((((`sakila`.`category` left join `sakila`.`film_category` on((`sakila`.`category`.`category_id` = `sakila`.`film_category`.`category_id`))) left join `sakila`.`film` on((`sakila`.`film_category`.`film_id` = `sakila`.`film`.`film_id`))) join `sakila`.`film_actor` on((`sakila`.`film`.`film_id` = `sakila`.`film_actor`.`film_id`))) join `sakila`.`actor` on((`sakila`.`film_actor`.`actor_id` = `sakila`.`actor`.`actor_id`))) group by `sakila`.`film`.`film_id`,`sakila`.`category`.`name`;


-- deployment: Creating film_list...
CREATE VIEW film_list AS select `sakila`.`film`.`film_id` AS `FID`,`sakila`.`film`.`title` AS `title`,`sakila`.`film`.`description` AS `description`,`sakila`.`category`.`name` AS `category`,`sakila`.`film`.`rental_rate` AS `price`,`sakila`.`film`.`length` AS `length`,`sakila`.`film`.`rating` AS `rating`,group_concat(concat(`sakila`.`actor`.`first_name`,' ',`sakila`.`actor`.`last_name`) separator ', ') AS `actors` from ((((`sakila`.`category` left join `sakila`.`film_category` on((`sakila`.`category`.`category_id` = `sakila`.`film_category`.`category_id`))) left join `sakila`.`film` on((`sakila`.`film_category`.`film_id` = `sakila`.`film`.`film_id`))) join `sakila`.`film_actor` on((`sakila`.`film`.`film_id` = `sakila`.`film_actor`.`film_id`))) join `sakila`.`actor` on((`sakila`.`film_actor`.`actor_id` = `sakila`.`actor`.`actor_id`))) group by `sakila`.`film`.`film_id`,`sakila`.`category`.`name`;


-- deployment: Creating actor_info...
CREATE SQL SECURITY INVOKER VIEW actor_info AS select `a`.`actor_id` AS `actor_id`,`a`.`first_name` AS `first_name`,`a`.`last_name` AS `last_name`,group_concat(distinct concat(`c`.`name`,': ',(select group_concat(`f`.`title` order by `f`.`title` ASC separator ', ') from ((`sakila`.`film` `f` join `sakila`.`film_category` `fc` on((`f`.`film_id` = `fc`.`film_id`))) join `sakila`.`film_actor` `fa` on((`f`.`film_id` = `fa`.`film_id`))) where ((`fc`.`category_id` = `c`.`category_id`) and (`fa`.`actor_id` = `a`.`actor_id`)))) order by `c`.`name` ASC separator '; ') AS `film_info` from (((`sakila`.`actor` `a` left join `sakila`.`film_actor` `fa` on((`a`.`actor_id` = `fa`.`actor_id`))) left join `sakila`.`film_category` `fc` on((`fa`.`film_id` = `fc`.`film_id`))) left join `sakila`.`category` `c` on((`fc`.`category_id` = `c`.`category_id`))) group by `a`.`actor_id`,`a`.`first_name`,`a`.`last_name`;


-- deployment: Creating film_actor.fk_film_actor_actor...
ALTER TABLE film_actor
    ADD CONSTRAINT fk_film_actor_actor FOREIGN KEY (actor_id)
    REFERENCES actor(actor_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating store.idx_unique_manager...
CREATE UNIQUE INDEX idx_unique_manager USING BTREE ON store(manager_staff_id);


-- deployment: Creating store.fk_store_staff...
ALTER TABLE store
    ADD CONSTRAINT fk_store_staff FOREIGN KEY (manager_staff_id)
    REFERENCES staff(staff_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating store.idx_fk_address_id...
CREATE INDEX idx_fk_address_id USING BTREE ON store(address_id);


-- deployment: Creating store.fk_store_address...
ALTER TABLE store
    ADD CONSTRAINT fk_store_address FOREIGN KEY (address_id)
    REFERENCES address(address_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating staff.idx_fk_store_id...
CREATE INDEX idx_fk_store_id USING BTREE ON staff(store_id);


-- deployment: Creating staff.fk_staff_store...
ALTER TABLE staff
    ADD CONSTRAINT fk_staff_store FOREIGN KEY (store_id)
    REFERENCES store(store_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating staff.idx_fk_address_id...
CREATE INDEX idx_fk_address_id USING BTREE ON staff(address_id);


-- deployment: Creating staff.fk_staff_address...
ALTER TABLE staff
    ADD CONSTRAINT fk_staff_address FOREIGN KEY (address_id)
    REFERENCES address(address_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating rental.rental_date...
CREATE UNIQUE INDEX rental_date USING BTREE ON rental(rental_date, inventory_id, customer_id);


-- deployment: Creating rental.idx_fk_staff_id...
CREATE INDEX idx_fk_staff_id USING BTREE ON rental(staff_id);


-- deployment: Creating rental.fk_rental_staff...
ALTER TABLE rental
    ADD CONSTRAINT fk_rental_staff FOREIGN KEY (staff_id)
    REFERENCES staff(staff_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating rental.idx_fk_inventory_id...
CREATE INDEX idx_fk_inventory_id USING BTREE ON rental(inventory_id);


-- deployment: Creating rental.fk_rental_inventory...
ALTER TABLE rental
    ADD CONSTRAINT fk_rental_inventory FOREIGN KEY (inventory_id)
    REFERENCES inventory(inventory_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating rental.idx_fk_customer_id...
CREATE INDEX idx_fk_customer_id USING BTREE ON rental(customer_id);


-- deployment: Creating rental.fk_rental_customer...
ALTER TABLE rental
    ADD CONSTRAINT fk_rental_customer FOREIGN KEY (customer_id)
    REFERENCES customer(customer_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating payment.idx_fk_staff_id...
CREATE INDEX idx_fk_staff_id USING BTREE ON payment(staff_id);


-- deployment: Creating payment.fk_payment_staff...
ALTER TABLE payment
    ADD CONSTRAINT fk_payment_staff FOREIGN KEY (staff_id)
    REFERENCES staff(staff_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating payment.idx_fk_customer_id...
CREATE INDEX idx_fk_customer_id USING BTREE ON payment(customer_id);


-- deployment: Creating payment.fk_payment_customer...
ALTER TABLE payment
    ADD CONSTRAINT fk_payment_customer FOREIGN KEY (customer_id)
    REFERENCES customer(customer_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating payment.fk_payment_rental...
CREATE INDEX fk_payment_rental USING BTREE ON payment(rental_id);


-- deployment: Creating payment.fk_payment_rental...
ALTER TABLE payment
    ADD CONSTRAINT fk_payment_rental FOREIGN KEY (rental_id)
    REFERENCES rental(rental_id)
    ON UPDATE CASCADE
    ON DELETE SET NULL;


-- deployment: Creating inventory.idx_store_id_film_id...
CREATE INDEX idx_store_id_film_id USING BTREE ON inventory(store_id, film_id);


-- deployment: Creating inventory.fk_inventory_store...
ALTER TABLE inventory
    ADD CONSTRAINT fk_inventory_store FOREIGN KEY (store_id)
    REFERENCES store(store_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating inventory.idx_fk_film_id...
CREATE INDEX idx_fk_film_id USING BTREE ON inventory(film_id);


-- deployment: Creating inventory.fk_inventory_film...
ALTER TABLE inventory
    ADD CONSTRAINT fk_inventory_film FOREIGN KEY (film_id)
    REFERENCES film(film_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating film_text.idx_title_description...
CREATE FULLTEXT INDEX idx_title_description ON film_text(title, description);


-- deployment: Creating film_category.fk_film_category_category...
CREATE INDEX fk_film_category_category USING BTREE ON film_category(category_id);


-- deployment: Creating film_category.fk_film_category_category...
ALTER TABLE film_category
    ADD CONSTRAINT fk_film_category_category FOREIGN KEY (category_id)
    REFERENCES category(category_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating film_actor.idx_fk_film_id...
CREATE INDEX idx_fk_film_id USING BTREE ON film_actor(film_id);


-- deployment: Creating film_actor.fk_film_actor_film...
ALTER TABLE film_actor
    ADD CONSTRAINT fk_film_actor_film FOREIGN KEY (film_id)
    REFERENCES film(film_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating film.idx_title...
CREATE INDEX idx_title USING BTREE ON film(title);


-- deployment: Creating film.idx_fk_original_language_id...
CREATE INDEX idx_fk_original_language_id USING BTREE ON film(original_language_id);


-- deployment: Creating film.fk_film_language_original...
ALTER TABLE film
    ADD CONSTRAINT fk_film_language_original FOREIGN KEY (original_language_id)
    REFERENCES language(language_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating film.idx_fk_language_id...
CREATE INDEX idx_fk_language_id USING BTREE ON film(language_id);


-- deployment: Creating film.fk_film_language...
ALTER TABLE film
    ADD CONSTRAINT fk_film_language FOREIGN KEY (language_id)
    REFERENCES language(language_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating customer.idx_last_name...
CREATE INDEX idx_last_name USING BTREE ON customer(last_name);


-- deployment: Creating customer.idx_fk_store_id...
CREATE INDEX idx_fk_store_id USING BTREE ON customer(store_id);


-- deployment: Creating customer.fk_customer_store...
ALTER TABLE customer
    ADD CONSTRAINT fk_customer_store FOREIGN KEY (store_id)
    REFERENCES store(store_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating customer.idx_fk_address_id...
CREATE INDEX idx_fk_address_id USING BTREE ON customer(address_id);


-- deployment: Creating customer.fk_customer_address...
ALTER TABLE customer
    ADD CONSTRAINT fk_customer_address FOREIGN KEY (address_id)
    REFERENCES address(address_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating city.idx_fk_country_id...
CREATE INDEX idx_fk_country_id USING BTREE ON city(country_id);


-- deployment: Creating city.fk_city_country...
ALTER TABLE city
    ADD CONSTRAINT fk_city_country FOREIGN KEY (country_id)
    REFERENCES country(country_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating address.idx_location...
CREATE SPATIAL INDEX idx_location ON address(location);


-- deployment: Creating address.idx_fk_city_id...
CREATE INDEX idx_fk_city_id USING BTREE ON address(city_id);


-- deployment: Creating address.fk_address_city...
ALTER TABLE address
    ADD CONSTRAINT fk_address_city FOREIGN KEY (city_id)
    REFERENCES city(city_id)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


-- deployment: Creating actor.idx_actor_last_name...
CREATE INDEX idx_actor_last_name USING BTREE ON actor(last_name);

